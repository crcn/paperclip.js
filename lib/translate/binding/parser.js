// Generated by CoffeeScript 1.7.0
(function() {
  var BaseParser, CollectionExpression, FnExpression, GroupExpression, JsExpression, ModifierExpression, OptionExpression, OptionsExpression, ParamsExpression, Parser, RefExpression, RefPathExpression, ScriptExpression, ScriptsExpression, StringExpression, TokenCodes, Tokenizer,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Tokenizer = require("./tokenizer");

  TokenCodes = Tokenizer.codes;

  BaseParser = require("../base/parser");

  FnExpression = require("./expressions/fn");

  JsExpression = require("./expressions/js");

  RefExpression = require("./expressions/ref");

  GroupExpression = require("./expressions/group");

  ParamsExpression = require("./expressions/params");

  StringExpression = require("./expressions/string");

  ScriptExpression = require("./expressions/script");

  OptionExpression = require("./expressions/option");

  ScriptsExpression = require("./expressions/scripts");

  OptionsExpression = require("./expressions/options");

  RefPathExpression = require("./expressions/refPath");

  ModifierExpression = require("./expressions/modifier");

  CollectionExpression = require("../base/collectionExpression");


  /*
   action:
   */

  Parser = (function(_super) {
    __extends(Parser, _super);


    /*
     */

    function Parser() {
      Parser.__super__.constructor.call(this, new Tokenizer());
    }


    /*
     */

    Parser.prototype._parse = function() {
      this._nextCode();
      return this._parseActionsOrOptions();
    };


    /*
     */

    Parser.prototype._parseActionsOrOptions = function() {
      var actions, isExpr, pn;
      actions = [];
      isExpr = !(pn = this._t.peekNext()) || pn[0] !== TokenCodes.COLON;
      if (this._t.current[0] === TokenCodes.BS) {
        this._nextCode();
        isExpr = false;
      }
      if (isExpr) {
        return new ScriptExpression(void 0, this._parseActionOptions());
      }
      while (this._t.current) {
        actions.push(this._parseAction());
        if (this._currentCode() === TokenCodes.COMA) {
          this._nextCode();
        }
      }
      return new ScriptsExpression(actions);
    };


    /*
     */

    Parser.prototype._parseAction = function() {
      var name;
      name = this._currentString();
      this._nextCode();
      this._nextCode();
      return new ScriptExpression(name, this._parseActionOptions());
    };


    /*
     */

    Parser.prototype._parseActionOptions = function() {
      switch (this._currentCode()) {
        case TokenCodes.LB:
          return this._parseMultiOptions();
        default:
          return this._parseReference();
      }
    };


    /*
     */

    Parser.prototype._parseMultiOptions = function() {
      var c, name, options;
      options = [];
      this._nextCode();
      while ((c = this._currentCode()) !== TokenCodes.RB) {
        name = this._currentString();
        this._expectNextCode(TokenCodes.COLON);
        this._nextCode();
        options.push(new OptionExpression(name, this._parseActionOptions()));
        if (this._currentCode() === TokenCodes.COMA) {
          this._nextCode();
        }
      }
      this._nextCode();
      return new OptionsExpression(options);
    };


    /*
     */

    Parser.prototype._parseReference = function() {
      var c, expressions, modifiers;
      expressions = [];
      modifiers = [];
      while (c = this._currentCode()) {
        if (c === TokenCodes.VAR || c === TokenCodes.U_VAR) {
          expressions.push(this._parseRef());
          c = this._currentCode();
        }
        if (c === TokenCodes.LP) {
          expressions.push(this._parseGroup());
          c = this._currentCode();
        }
        if (c === TokenCodes.LB) {
          expressions.push(this._parseActionOptions());
          c = this._currentCode();
        }
        if (c === TokenCodes.STRING) {
          expressions.push(new StringExpression(this._currentString()));
          c = this._nextCode();
        }
        while (c === TokenCodes.PIPE) {
          expressions.push(this._parsePipe(expressions.pop()));
          c = this._currentCode();
        }
        if (~[TokenCodes.RP, TokenCodes.RB].indexOf(c)) {
          break;
        }
        if (!c || ~[TokenCodes.COMA].indexOf(c)) {
          break;
        }
        expressions.push(new JsExpression(this._currentString()));
        this._nextCode();
      }
      if (!expressions.length) {
        return void 0;
      }
      return new CollectionExpression(expressions);
    };


    /*
     filter item.name > 5, test;
     */

    Parser.prototype._parsePipe = function(expressions) {
      var name, params;
      this._nextCode();
      name = this._currentString();
      params = [];
      this._nextCode();
      return new ModifierExpression(name, this._parseParams(), expressions);
    };


    /*
     */

    Parser.prototype._parseParams = function() {
      return new ParamsExpression(this._parseParams2());
    };


    /*
     */

    Parser.prototype._parseParams2 = function() {
      var c, params;
      this._expectCurrentCode(TokenCodes.LP);
      params = [];
      while (c = this._nextCode()) {
        if (c === TokenCodes.RP) {
          break;
        }
        params.push(this._parseReference());
        c = this._currentCode();
        if (c !== TokenCodes.COMA) {
          break;
        }
      }
      this._nextCode();
      return params;
    };


    /*
     */

    Parser.prototype._parseGroup = function() {
      return new GroupExpression(this._parseParams2());
    };


    /*
     */

    Parser.prototype._parseRef = function() {
      var assign, c, castAs, name, refs, unbound;
      c = this._currentCode();
      refs = [];
      assign = null;
      if (c === TokenCodes.U_VAR) {
        unbound = true;
        c = this._nextCode();
      }
      while (c === TokenCodes.VAR) {
        name = this._currentString();
        c = this._nextCode();
        if (c === TokenCodes.U_VAR) {
          c = this._nextCode();
        }
        if (c === TokenCodes.LP) {
          refs.push(new FnExpression(name, this._parseParams()));
          c = this._currentCode();
        } else {
          refs.push(new RefExpression(name));
        }
        if (c === TokenCodes.DOT) {
          c = this._nextCode();
        }
      }
      if (c === TokenCodes.AS) {
        this._nextCode();
        castAs = this._currentString();
        this._nextCode();
      }
      if (c === TokenCodes.ASSIGN) {
        this._nextCode();
        assign = this._parseReference();
      }
      return new RefPathExpression(refs, castAs, assign, unbound);
    };

    return Parser;

  })(BaseParser);

  module.exports = new Parser();

}).call(this);
