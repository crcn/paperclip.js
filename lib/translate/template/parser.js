// Generated by CoffeeScript 1.7.0
(function() {
  var AttributeExpression, AttributesExpression, BaseParser, BindingExpression, ChildrenExpression, CollectionExpression, NodeExpression, Parser, RootExpression, StringExpression, StringNodeExpression, TextBindingExpression, TextStringExpression, TokenCodes, Tokenizer, bindingParser,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BaseParser = require("../base/parser");

  Tokenizer = require("./tokenizer");

  TokenCodes = Tokenizer.Codes;

  bindingParser = require("../binding/parser");

  RootExpression = require("./expressions/root");

  NodeExpression = require("./expressions/node");

  StringExpression = require("./expressions/string");

  BindingExpression = require("./expressions/binding");

  ChildrenExpression = require("./expressions/children");

  AttributeExpression = require("./expressions/attribute");

  AttributesExpression = require("./expressions/attributes");

  CollectionExpression = require("./expressions/collection");

  TextStringExpression = require("./expressions/textString");

  TextBindingExpression = require("./expressions/textBinding");

  StringNodeExpression = require("./expressions/stringNode");

  Parser = (function(_super) {
    __extends(Parser, _super);


    /*
     */

    function Parser() {
      Parser.__super__.constructor.call(this);
      this._t = new Tokenizer();
    }


    /*
     */

    Parser.prototype._parse = function() {
      var expr, expressions, i;
      expressions = [];
      i = 0;
      this._nextCode();
      while (this._t.current) {
        expr = this._parseExpression();
        if (expr) {
          expressions.push(expr);
        }
      }
      return new RootExpression(new CollectionExpression(expressions));
    };


    /*
     */

    Parser.prototype._parseExpression = function() {
      var ccode;
      if (!(ccode = this._currentCode())) {
        return null;
      }
      if (ccode === TokenCodes.LT) {
        return this._parseNode();
      } else if (ccode === TokenCodes.SBLOCK) {
        return this._parseBindingBlock();
      } else if (ccode === TokenCodes.SN) {
        return this._parseStringNode();
      } else {
        return this._parseText();
      }
    };


    /*
     */

    Parser.prototype._parseStringNode = function() {
      var cs;
      cs = this._currentString();
      this._nextCode();
      return new StringNodeExpression(cs);
    };


    /*
     */

    Parser.prototype._parseNode = function() {
      var attributes, cchar, children, name;
      name = this._nextString();
      this._nextCode();
      attributes = this._parseAttributes();
      while ((cchar = this._currentCode()) && cchar) {
        if (cchar === TokenCodes.GT) {
          this._nextCode();
          children = this._parseChildren(name);
          break;
        } else if (cchar === TokenCodes.ETNC) {
          this._nextCode();
          break;
        } else {
          this._nextCode();
        }
      }
      return new NodeExpression(name, attributes, children);
    };


    /*
     */

    Parser.prototype._parseAttributes = function() {
      var attrs, ccode;
      attrs = [];
      while (ccode = this._currentCode()) {
        if ((TokenCodes.GT | TokenCodes.ETNC) & ccode) {
          break;
        }
        if (ccode === TokenCodes.WS) {
          this._nextCode();
          continue;
        }
        attrs.push(this._parseAttribute());
      }
      if (!attrs.length) {
        return null;
      }
      return new AttributesExpression(attrs);
    };


    /*
     */

    Parser.prototype._parseChildren = function(nodeName) {
      var ccode, children, ended;
      children = [];
      ended = false;
      while ((ccode = this._currentCode()) && ccode) {
        if ((TokenCodes.GT | TokenCodes.EBLOCK) & ccode) {
          break;
        }
        if (ccode === TokenCodes.ETAG) {
          ended = true;
          this._nextCode();
          break;
        }
        children.push(this._parseExpression());
      }
      if (!ended) {
        throw new Error("tag <" + nodeName + "> has no ending tag </" + nodeName + ">");
      }
      if (!children.length) {
        return null;
      }
      return new CollectionExpression(children);
    };


    /*
     */

    Parser.prototype._parseAttribute = function() {
      var name, value;
      name = this._currentString();
      if (this._nextCode() === TokenCodes.EQ) {
        this._nextCodeSkipWs();
        value = this._parseAttributeValue();
      }
      return new AttributeExpression(name, value);
    };


    /*
     */

    Parser.prototype._parseAttributeValue = function() {
      var quoteCode, ret;
      quoteCode = this._currentCode();
      this._nextCode();
      ret = this._parseAttrTextUntil(quoteCode);
      this._nextCodeSkipWs();
      return ret;
    };


    /*
     */

    Parser.prototype._parseText = function() {
      return this._parseTextUntil(TokenCodes.EBLOCK | TokenCodes.SBLOCK | TokenCodes.LT | TokenCodes.ETAG);
    };


    /*
     */

    Parser.prototype._parseTextUntil = function(scode) {
      var ccode, items, str;
      items = [];
      while (!((ccode = this._currentCode()) & scode) && ccode) {
        if (ccode === TokenCodes.LM) {
          items.push(this._parseTextBinding());
        } else {
          str = this._parseTextString(TokenCodes.LM | scode);
          if (str) {
            items.push(str);
          }
        }
      }
      return new CollectionExpression(items);
    };


    /*
     */

    Parser.prototype._parseAttrTextUntil = function(scode) {
      var ccode, items, str;
      items = [];
      while (!((ccode = this._currentCode()) & scode) && ccode) {
        if (ccode === TokenCodes.LM) {
          items.push(this._parseScript());
        } else {
          str = this._parseString(TokenCodes.LM | scode);
          if (str) {
            items.push(str);
          }
        }
      }
      return new CollectionExpression(items);
    };


    /*
     */

    Parser.prototype._parseString = function(scode) {
      var buffer, ccode;
      buffer = [];
      while (!((ccode = this._currentCode()) & scode) && ccode) {
        buffer.push(this._currentString());
        this._nextCode();
      }
      return new StringExpression(buffer.join(""));
    };


    /*
     */

    Parser.prototype._parseTextString = function(scode) {
      return new TextStringExpression(this._parseString(scode));
    };


    /*
     */

    Parser.prototype._parseBindingBlock = function(isChild) {
      var ccode, child, children, script;
      script = this._parseScript(isChild);
      children = [];
      while ((ccode = this._currentCode()) !== TokenCodes.EBLOCK && ccode) {
        children.push(this._parseExpression());
      }
      this._nextCode();
      if (this._currentCode() !== TokenCodes.RM) {
        this._t.putBack();
        child = this._parseBindingBlock(true);
      } else {
        this._nextCode();
      }
      return new BindingExpression(script, new CollectionExpression(children), child);
    };


    /*
     */

    Parser.prototype._parseTextBinding = function() {
      return new TextBindingExpression(this._parseScript());
    };


    /*
     */

    Parser.prototype._parseScript = function(isChild) {
      var buffer, ccode, script;
      this._nextCode();
      buffer = [];
      while (((ccode = this._currentCode()) !== TokenCodes.RM) && ccode) {
        buffer.push(this._currentString());
        this._nextCode();
      }
      if (isChild) {
        buffer.unshift("/");
      }
      script = bindingParser.parse(buffer.join(""));
      this._nextCode();
      return script;
    };

    return Parser;

  })(BaseParser);

  module.exports = new Parser();

}).call(this);
