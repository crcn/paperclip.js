// Generated by CoffeeScript 1.7.0
(function() {
  var BaseTokenizer, Codes, Tokenizer,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  BaseTokenizer = require("../base/tokenizer");


  /*
   <div id="test">
  
   </div>
   */

  Codes = (function() {
    function Codes() {}

    Codes.OTHER = -1;

    Codes.WORD = 2;

    Codes.LT = Codes.WORD << 1;

    Codes.GT = Codes.LT << 1;

    Codes.ETNC = Codes.GT << 1;

    Codes.BS = Codes.ETNC << 1;

    Codes.EQ = Codes.BS << 1;

    Codes.STRING = Codes.EQ << 1;

    Codes.LM = Codes.STRING << 1;

    Codes.RM = Codes.LM << 1;

    Codes.SBLOCK = Codes.RM << 1;

    Codes.EBLOCK = Codes.SBLOCK << 1;

    Codes.QUOTE = Codes.EBLOCK << 1;

    Codes.SQUOTE = Codes.QUOTE << 1;

    Codes.ETAG = Codes.SQUOTE << 1;

    Codes.BLOCK = Codes.ETAG << 1;

    Codes.CHAR = Codes.BLOCK << 1;

    Codes.COMMENT = Codes.CHAR << 1;

    Codes.HASH = Codes.COMMENT << 1;

    Codes.WS = Codes.HASH << 1;

    Codes.SN = Codes.WS << 1;

    Codes.UNBOUND_VAR = Codes.SN << 1;

    return Codes;

  })();

  Tokenizer = (function(_super) {
    __extends(Tokenizer, _super);


    /*
     */

    Tokenizer.Codes = Codes;


    /*
     */

    function Tokenizer() {
      Tokenizer.__super__.constructor.call(this);
      this._s.skipWhitespace(false);
    }


    /*
     */

    Tokenizer.prototype._next = function() {
      var buffer, cchar, word;
      if (this._s.isAZ()) {
        return this._t(Codes.WORD, this._s.next(/[$_\-a-zA-Z0-9]+/));
      }
      if ((cchar = this._s.cchar()) === "<") {
        if (this._s.peek(4) === "<!--") {
          this._s.skip(4);
          buffer = ["<!--"];
          while ((cchar = this._s.cchar()) && cchar) {
            if (cchar === "-") {
              if (this._s.peek(2) === "->") {
                this._s.skip(2);
                buffer.push("->");
                break;
              }
            }
            buffer.push(cchar);
            this._s.nextChar();
          }
          return this._next();
        }
        if (this._s.peek(2) === "<!") {
          buffer = [];
          while ((cchar = this._s.cchar()) && cchar) {
            buffer.push(cchar);
            if (cchar === ">") {
              break;
            }
            this._s.nextChar();
          }
          return this._t(Codes.SN, buffer.join(""));
        } else {
          if (this._s.peek(2) === "</") {
            word = this._s.next(/[a-zA-Z0-9]+/);
            this._s.skip(1);
            return this._t(Codes.ETAG, word);
          }
          return this._t(Codes.LT, "<");
        }
      } else if (cchar === "/") {
        if (this._s.peek(2) === "/>") {
          this._s.skip(1);
          return this._t(Codes.ETNC, "/>");
        }
        return this._t(Codes.BS, "/");
      } else if (cchar === ">") {
        return this._t(Codes.GT, ">");
      } else if (this._s.isWs()) {
        this._s.next(/[\s\r\n\t]+/);
        return this._t(Codes.WS, " ");
      } else if (cchar === "{") {
        if (this._s.peek(3) === "{{/") {
          this._s.skip(2);
          return this._t(Codes.EBLOCK, "{{/");
        }
        if (this._s.peek(3) === "{{#") {
          this._s.skip(2);
          return this._t(Codes.SBLOCK, "{{#");
        }
        if (this._s.peek(2) === "{{") {
          this._s.nextChar();
          return this._t(Codes.LM, "{{");
        }
      } else if (cchar === "}") {
        if (this._s.peek(2) === "}}" && this._s.peek(3) !== "}}}") {
          this._s.nextChar();
          return this._t(Codes.RM, "}}");
        }
      } else if (cchar === "=") {
        return this._t(Codes.EQ, "=");
      } else if (cchar === "\"") {
        return this._t(Codes.QUOTE, "\"");
      } else if (cchar === "\'") {
        return this._t(Codes.SQUOTE, "\'");
      } else if (cchar === "#") {
        return this._t(Codes.HASH, "#");
      }
      return this._t(Codes.CHAR, this._s.cchar());
    };

    return Tokenizer;

  })(BaseTokenizer);

  module.exports = Tokenizer;

}).call(this);
